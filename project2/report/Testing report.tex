\documentclass[12pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings} % Source code formatting and highlighting
\usepackage{color}
\usepackage{pgfplotstable} % Generates table from .csv
\usepackage{booktabs} % For \toprule, \midrule and \bottomrule
\usepackage[left=1.00in, right=1.00in, top=1.00in, bottom=1.00in]{geometry}
\author{Brett Worley}
\title{Project 2: Password checker testing}
\date{version: \today}
\begin{document}

\maketitle
\tableofcontents



\section{Introduction}

The program to be developed is a password checking module. It will be used to check if a password
meets the requirements of the system shown in the requirements section. This document covers the 
various testing strategies used to test the program. The finalized test plan was developed by using
Equivalence class and boundary testing, Orthogonal array testing, and Decision table testing. Along
with the code, a testing harness was created to provide automated testing and manual testing to check
the coverage of the test cases.

\subsection{Requirements}

The requirements of the password checking program are as follows.

\begin{enumerate}

\item The new password shall be at least 9 characters long, and no longer than
24 characters.
\item New passwords cannot contain any blank spaces, and must contain only numberals, upper-case and lower-case letters, and
the specials characters listed in Requirement 4.
\item All new passwords must contain at least two upper case letters, at least two lower case
letters, and at least two numerals.
\item New passwords must contain at least two special characters from the following list: 
  !  @  \#  \$  \%  \&  *  )  (  ]  [  \}  \{  $>$  $<$  ; 
   :  .  ,  /  $|$   \textbackslash  \~{}  ?  \_  $-$  $+$  $=$ 

\item New passwords cannot be similar to any of the other two previous passwords, with ``similar to'' defined
as ``containing an identical five-character substring (either forward or backward), independent of letter
case (for example, a5\%Km and a5\%kM would be considered identical substrings).

\end{enumerate}

\subsection{Automated testing file format}

The testing harness program was developed to allow automated testing. It reads in a file given to the
program and will run through each test case, after each test case it will output whether it
passed or failed. The file to be read must match the following specified format for each test case.

\begin{center}
New password \\
Current password \\
Previous password \\
A or R (Case is ignored)
\end{center}

For this file format, the A or R line is for the expected output for each test case. The expect output
line also allows for a comment following the A or R, this is to help the tester keep track of
what is being tested against in this case.

\section{Equivalence class and boundary testing}

\subsection{Introduction}
To implement equivalence classes and boundary testing, we will need to analyze the requirements
for the system and develop equivalence classes that will show the border values to test against. By going through the requirements for the system, we can identify the border conditions and come up with the following equivalence partitions shown in table 1.
The border conditions are important, as they are the most likely place that the system will fail on and around.  Having these cases also enables testers to trim down similar or equivalent test cases that essentially test the same values, compared against the border conditions.

% Possibly import the class partitions as figures from the powerpoint slides
\begin{table}[h!]
  \begin{center}
    \caption{Equivalence Partitions.}
    \label{tab:Equiv partitions}
    
    % Length settings
    \begin{tabular}{||c|m{4cm}|m{5cm}||}
    \hline
    Less than 9 characters & At least 9 characters and not more than 24
    characters & More than 24 characters \\
    
    % Space settings
    \hline \hline
    \multicolumn{1}{||c|}{Contains no blank spaces} & \multicolumn{2}{c||}{Contains no blank spaces} \\
    
    % Lower case settings
    \hline \hline
    \multicolumn{1}{||c|}{Contains insufficient lower case} 
    & \multicolumn{2}{c||}{Contains sufficient lower case} \\
    
    % Upper case settings
    \hline \hline
    \multicolumn{1}{||c|}{Contains insufficient upper case} 
    & \multicolumn{2}{c||}{Contains sufficient upper case} \\
    
    % Number settings
    \hline \hline
    \multicolumn{1}{||c|}{Contains insufficient numbers} 
    & \multicolumn{2}{c||}{Contains sufficient numbers} \\
    
    % Special character settings
    \hline \hline
    \multicolumn{1}{||c|}{Contains insufficient special characters} 
    & \multicolumn{2}{c||}{Contains sufficient special characters} \\
    
    % Previous password settings
    \hline \hline
    \multicolumn{1}{||c|}{Contains a identical five-character substring}
    & \multicolumn{2}{c||}{Does not contain a indentical five-character subtring} \\
    \hline
    \end{tabular}
  \end{center}
\end{table}

With these equivalence partitions, we are able to generate simple test cases based on passing or failing the classes one at a time.
The following test plan is made up of 8 test cases that are designed to fail a certain requirement of the system.
\newline
% Table for the special characters allowed in the password program
%\begin{table}[h!]
%  \begin{center}
%    \caption{Special Characters Allowed}
%    \label{tab:specials}
%    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
%    \hline
%    ! & @ & \# & \$ & \% & \& & * &  ) & ( & ] & [ & \} & \{ & $>$ & $<$ & ; 
%    & : & . & , & / & $|$ &  \textbackslash & \~{} & ? & \_ & $-$ & $+$ & $=$ \\
%    \hline
%    \end{tabular}
%  \end{center}
%\end{table}

\newcommand{\specialcell}[2][c]{% Custom talbe lines, set for 3 rows in one table cell
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\centering Equivalence class and Boundary Test Plan
% Valid Password samples

% GUha891))
% \#558\#\&;DoGs
% AVery990\#\^{}
% SimPass12!!
% ToT86635ss/\textless

% Valid case
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 1} \\
  \hline
  Purpose & Testing a valid password \\
  \hline
  Input & DahatB2559\_@ \\
  \hline
  Previous Passwords & \specialcell{ToT86635ss/\textless\\AVery990\#\^{}\\\#558\#\&;DoGs} \\% UolD2663!#
  \hline
  Expected Output & ACCEPTED \\
  \hline
  \end{tabular}
\end{center}
\vspace{1mm}
% Too Similar case
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 2} \\
  \hline
  Purpose & Testing against a similar password \\
  \hline
  Input & SsaPmis628@@ \\
  \hline
  Previous Passwords &  \specialcell{\#558\#\&;DoGs\\AVery990\#\^{}\\SimPass12!!} \\
  \hline
  Expected Output & REJECTED: password too similar to a previous password \\
  \hline
  \end{tabular}
\end{center}
\vspace{1mm}
% Space fail case
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 3} \\
  \hline
  Purpose & Testing against a password containing a space\\
  \hline
  Input & \&\^{}!aaCH91 chat \\
  \hline
  Previous Passwords &  \specialcell{\#558\#\&;DoGs\\AVery990\#\^{}\\ToT86635ss/\textless} \\
  \hline
  Expected Output & REJECTED: password contains a space \\
  \hline
  \end{tabular}
\end{center}
\vspace{1mm}
% Lower case test
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 4} \\
  \hline
  Purpose & Testing against a password with not enough lower case letters \\
  \hline
  Input & \#\$678123HOUSE \\
  \hline
  Previous Passwords &  \specialcell{ToT86635ss/\textless\\AVery990\#\^{}\\SimPass12!!} \\
  \hline
  Expected Output & REJECTED: password does not have enough lower case letters \\
  \hline
  \end{tabular}
\end{center}
\vspace{1mm}
% Upper case test
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 5} \\
  \hline
  Purpose & Testing against password with not enough upper case letters \\
  \hline
  Input & lowercasepasswords!;123 \\
  \hline
  Previous Passwords &  \specialcell{\#558\#\&;DoGs\\AVery990\#\^{}\\ToT86635ss/\textless} \\
  \hline
  Expected Output & REJECTED: password does not have enough upper case letters \\
  \hline
  \end{tabular}
\end{center}
\vspace{1mm}
% Number test
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 6} \\
  \hline
  Purpose & Testing against not enough numbers \\
  \hline
  Input & NumberBoycott\_? \\
  \hline
  Previous Passwords &  \specialcell{\#558\#\&;DoGs\\GUha891))\\SimPass12!!} \\
  \hline
  Expected Output & REJECTED: password does not have enough numbers \\
  \hline
  \end{tabular}
\end{center}
\vspace{1mm}
% Short password test
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 7} \\
  \hline
  Purpose & Testing against a short password \\
  \hline
  Input & Do12ah\_$=$ \\
  \hline
  Previous Passwords &  \specialcell{\#558\#\&;DoGs\\GUha891))\\SimPass12!!} \\
  \hline
  Expected Output & REJECTED: password is too short \\
  \hline
  \end{tabular}
\end{center}
\vspace{1mm}
% Long password test
\begin{center}
  \begin{tabular}{||c|c||}
  \hline
  \multicolumn{2}{||c||}{Test Case 8} \\
  \hline
  Purpose & Testing against not enough numbers \\
  \hline
  Input & WAYtooLong\_\_$+$$=$8835houseing40 \\
  \hline
  Previous Passwords &  \specialcell{\#558\#\&;DoGs\\GUha891))\\SimPass12!!} \\
  \hline
  Expected Output & REJECTED: password is too long \\
  \hline
  \end{tabular}
\end{center}



\section{Orthogonal array testing}

\subsection{Introduction}

\section{Decision table testing}

\subsection{Introduction}

\section{Code}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\begin{lstlisting}
/*
 * Brett Worley
 * CEG-3110-01
 */
#include "password_checker.h"

/*
 * Main function for processing a password entered by the user. It runs
 * through all the requirements checks for a valid password and will
 * output if the password is valid or invalid.
 */
int password_checker(const char* new_pass, const char* cur_pass, const char* pre_pass)
{
	int valid_password = FALSE;
	int len = strlen(new_pass);

	/* If the password entered is not long enough or too long, then we will
	not bother to check if it's valid. */
	if(len < 9 || len > 50) {
		printf("Rejected: Invalid password length.\n");
		return valid_password;
	}

	/* Check that all the requirements are met for the currently entered
	password */
	if(check_upper(new_pass) && check_lower(new_pass) && check_digit(new_pass)
		&& check_special(new_pass) && check_no_space(new_pass)
		&& !check_similar(new_pass, cur_pass, pre_pass)) {
		valid_password = TRUE;
	}

	return valid_password;
}

/*
 * Checks the given string for upper case characters.
 * If two or more are found, then it returns true; else it returns false.
 */
int check_upper(const char* str)
{
	int count = 0;

	while(*str) {

		if(isupper(*str++)) {
			count++;
		}
	}

	if(count >= 2) {
		return TRUE;
	} else {
		printf("Rejected: Not enough Upper case.\n");
		return FALSE;
	}
}

/*
 * Checks the given string for lower case characters.
 * If two or more are found, then it returns true; else it returns false.
 */
int check_lower(const char* str)
{
	int count = 0;

	while(*str) {

		if(islower(*str++)) {
			count++;
		}
	}

	if(count >= 2) {
		return TRUE;
	} else {
		printf("Rejected: Not enough Lower case.\n");
		return FALSE;
	}
}

/*
 * Checks the given string for any whitespace characters.
 * If one is found, it returns false; else it returns true.
 */
int check_no_space(const char* str)
{
	while(*str) {

		if(isspace(*str++)) {
			printf("Rejected: Space found.\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * Checks the given string for numeric digits.
 * If more than two are found, then it will return true; else it returns false.
 */
int check_digit(const char* str)
{
	int count = 0;

	while(*str) {

		if(isdigit(*str++)) {
			count++;
		}
	}

	if(count >= 2) {
		return TRUE;
	} else {
		printf("Rejected: Not enough numbers.\n");
		return FALSE;
	}
}

/*
 * Checks the given string against the allowed special characters.
 * If two or more are found, then it returns true; else it returns false.
 */
int check_special(const char* str)
{
	int i, len, count = 0;
	int valid_char = FALSE;
	const char* ptr;
	char special[] = { '!', '@', '#', '$', '%', '&', '*', ')', '(', ']', '[',
			'}', '{', '>', '<', ';', ':', '.', ',', '/', '|',
			'\\' , '~', '?', '_', '-', '+', '='};
	len = sizeof(special) / sizeof(char);

	ptr = str;

	while(*ptr) {
		
		valid_char = FALSE;

		if(isalnum(*ptr)) {
			valid_char = TRUE;
		}

		for(i = 0; i < len; i++) {
			if(*ptr == special[i]) {
				count++;
				valid_char = TRUE;
			}
		}

		if(!valid_char) {
			printf("Rejected: Invalid character found.\n");
			return FALSE;
		}

		ptr++;
	}

	ptr = str;


	if(count >= 2) {
		return TRUE;
	} else {
		printf("Rejected: Not enough special characters.\n");
		return FALSE;
	}
}

/*
 * Begins checking the passwords to see if they contain a 5 character
 * substring. If a matching character is found, then it calls the other
 * checking functions.
*/
int check_similar(const char* new_pass, const char* cur_pass,
		const char* pre_pass)
{
	int similar = FALSE;
	int i, j;
	size_t newlen, curlen, prelen;
	
	newlen = strlen(new_pass);
	curlen = strlen(cur_pass);
	prelen = strlen(pre_pass);

	for(i = 0; i < newlen; i++) {
	
		for(j = 0; j < curlen; j++) {

			/* detect a matching letter */
			if((isalpha(new_pass[i])) && (isalpha(cur_pass[j]))) {
				if(lettercmp(new_pass, i, cur_pass, j)) {
					similar = found_match_char(new_pass,
						newlen, i, cur_pass, curlen, j);
				}
			} else {
				/* detect a matching non-letter*/
				if(!strncmp(&new_pass[i],
				&cur_pass[j], sizeof(char))) {
					similar = found_match_char(new_pass,
						newlen, i, cur_pass, curlen, j);
				}
			}
			if(similar) {
				printf("Rejected: passwords too similar.\n");
				return TRUE;
			}
		}

		for(j = 0; j < prelen; j++) {
		
			/* detect a matching letter */
			if((isalpha(new_pass[i])) && (isalpha(pre_pass[j]))) {
				if(lettercmp(new_pass, i, pre_pass, j)) {
					similar = found_match_char(new_pass,
						newlen, i, pre_pass, prelen, j);
				}
			} else {
				/* detect a matching non-letter*/
				if(!strncmp(&new_pass[i],
				&pre_pass[j], sizeof(char))) {
					similar = found_match_char(new_pass,
						newlen, i, pre_pass, prelen, j);
				}
			}
			if(similar) {
				printf("Rejected: passwords too similar.\n");
				return TRUE;
			}
		}
	}

	return FALSE;
}

/*
 *
*/
int found_match_char(const char* new_pass, int newlen, int new_index,
		const char* old_pass, int oldlen, int old_index)
{
	if(chk_forward(new_pass, newlen, new_index, old_pass,
	oldlen, old_index) || chk_backward(new_pass, newlen, new_index,
	old_pass, oldlen, old_index) || chk_bforward(new_pass, newlen,
	new_index, old_pass, oldlen, old_index) || chk_fbackward(new_pass,
	newlen, new_index, old_pass, oldlen, old_index)) {
		
		return TRUE;
	} else {
		return FALSE;
	}
}

/*
 *
*/
int chk_forward(const char* new_pass, int newlen, int new_index,
		const char* old_pass, int oldlen, int old_index)
{
	int i;
	int same = FALSE;
	int count = 1;
	const int substrlen = 5;
	new_index++; old_index++;

	for(i = 1; i < substrlen; i++) {

		if((isalpha(new_pass[new_index])) &&
		(isalpha(old_pass[old_index]))) {
			if(lettercmp(new_pass, new_index, old_pass,
			old_index)) {
				count++;
			} else {
				count = 1;
			}
		} else {

			if(!strncmp(&new_pass[new_index],
			&old_pass[old_index], sizeof(char))) {
				count++;
			} else {
				count = 1;
			}
		}
		old_index = (old_index + 1) % oldlen;
		new_index = (new_index + 1) % newlen;
	}

	if(count >= 5) {
		same = TRUE;
	}
	
	return same;
}

int chk_backward(const char* new_pass, int newlen, int new_index,
		const char* old_pass, int oldlen, int old_index)
{
	int i;
	int same = FALSE;
	int count = 1;
	const int substrlen = 5;
	new_index--; old_index--;

	for(i = 1; i < substrlen; i++) {

		if((isalpha(new_pass[new_index])) &&
		(isalpha(old_pass[old_index]))) {
			if(lettercmp(new_pass, new_index, old_pass,
			old_index)) {
				count++;
			} else {
				count = 1;
			}
		} else {

			if(!strncmp(&new_pass[new_index],
			&old_pass[old_index], sizeof(char))) {
				count++;
			} else {
				count = 1;
			}
		}
		old_index = (old_index - 1) % oldlen;
		new_index = (new_index - 1) % newlen;

		if(old_index < 0) {
			old_index = oldlen - 1;
		}
		if(new_index < 0) {
			new_index = newlen - 1;
		}
	}

	if(count >= 5) {
		same = TRUE;
	}
	
	return same;

}

int chk_bforward(const char* new_pass, int newlen, int new_index,
		const char* old_pass, int oldlen, int old_index)
{
	int i;
	int same = FALSE;
	int count = 1;
	const int substrlen = 5;
	new_index++; old_index--;

	for(i = 1; i < substrlen; i++) {

		if((isalpha(new_pass[new_index])) &&
		(isalpha(old_pass[old_index]))) {
			if(lettercmp(new_pass, new_index, old_pass,
			old_index)) {
				count++;
			} else {
				count = 1;
			}
		} else {

			if(!strncmp(&new_pass[new_index],
			&old_pass[old_index], sizeof(char))) {
				count++;
			} else {
				count = 1;
			}
		}
		old_index = (old_index - 1) % oldlen;
		new_index = (new_index + 1) % newlen;

		if(old_index < 0) {
			old_index = oldlen -1;
		}
	}

	if(count >= 5) {
		same = TRUE;
	}
	
	return same;
}

int chk_fbackward(const char* new_pass, int newlen, int new_index,
		const char* old_pass, int oldlen, int old_index)
{
	int i;
	int same = FALSE;
	int count = 1;
	const int substrlen = 5;
	new_index--; old_index++;

	for(i = 1; i < substrlen; i++) {

		if((isalpha(new_pass[new_index])) &&
		(isalpha(old_pass[old_index]))) {
			if(lettercmp(new_pass, new_index, old_pass,
			old_index)) {
				count++;
			} else {
				count = 1;
			}
		} else {

			if(!strncmp(&new_pass[new_index],
			&old_pass[old_index], sizeof(char))) {
				count++;
			} else {
				count = 1;
			}
		}
		old_index = (old_index + 1) % oldlen;
		new_index = (new_index - 1) % newlen;

		if(new_index < 0) {
			new_index = newlen - 1;
		}
	}

	if(count >= 5) {
		same = TRUE;
	}
	
	return same;
}

/*
 * Function used to compare letter to see if they are the same.
 * It will pull one character each from both of the strings and convert
 * them into lower case, and then see if they are the same letter.
 * returns: true if they are the same, false if not
*/
int lettercmp(const char* new_pass, int new_index, const char* old_pass,
		int old_index)
{
	char a, b;

	a = tolower(new_pass[new_index]);
	b = tolower(old_pass[old_index]);

	if( a == b) {
		return TRUE;
	} else {
		return FALSE;
	}
}

\end{lstlisting}


\end{document}
